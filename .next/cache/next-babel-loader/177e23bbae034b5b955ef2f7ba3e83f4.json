{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _nodeHtmlParser = require(\"node-html-parser\");\n\nvar _constants = require(\"./constants\");\n\nconst MIDDLEWARE_TIME_BUDGET = 10;\nconst middlewareRegistry = [];\n\nfunction registerPostProcessor(name, middleware, condition) {\n  middlewareRegistry.push({\n    name,\n    middleware,\n    condition: condition || null\n  });\n}\n\nasync function processHTML(html, data, options) {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html;\n  }\n\n  const postProcessData = {\n    preloads: {\n      images: []\n    }\n  };\n  const root = (0, _nodeHtmlParser.parse)(html);\n  let document = html; // Calls the middleware, with some instrumentation and logging\n\n  async function callMiddleWare(middleware, name) {\n    let timer = Date.now();\n    middleware.inspect(root, postProcessData, data);\n    const inspectTime = Date.now() - timer;\n    document = await middleware.mutate(document, postProcessData, data);\n    timer = Date.now() - timer;\n\n    if (timer > MIDDLEWARE_TIME_BUDGET) {\n      console.warn(`The postprocess middleware \"${name}\" took ${timer}ms(${inspectTime}, ${timer - inspectTime}) to complete. This is longer than the ${MIDDLEWARE_TIME_BUDGET} limit.`);\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i];\n\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(middlewareRegistry[i].middleware, middlewareRegistry[i].name);\n    }\n  }\n\n  return document;\n}\n\nclass FontOptimizerMiddleware {\n  constructor() {\n    this.fontDefinitions = [];\n\n    this.mutate = async (markup, _data, options) => {\n      let result = markup;\n\n      if (!options.getFontDefinition) {\n        return markup;\n      }\n\n      for (const key in this.fontDefinitions) {\n        const url = this.fontDefinitions[key];\n\n        if (result.indexOf(`<style data-href=\"${url}\">`) > -1) {\n          // The font is already optimized and probably the response is cached\n          continue;\n        }\n\n        const fontContent = options.getFontDefinition(url);\n        result = result.replace('</head>', `<style data-href=\"${url}\">${fontContent.replace(/(\\n|\\s)/g, '')}</style></head>`);\n      }\n\n      return result;\n    };\n  }\n\n  inspect(originalDom, _data, options) {\n    if (!options.getFontDefinition) {\n      return;\n    } // collecting all the requested font definitions\n\n\n    originalDom.querySelectorAll('link').filter(tag => tag.getAttribute('rel') === 'stylesheet' && tag.hasAttribute('data-href') && _constants.OPTIMIZED_FONT_PROVIDERS.some(url => tag.getAttribute('data-href').startsWith(url))).forEach(element => {\n      const url = element.getAttribute('data-href');\n      this.fontDefinitions.push(url);\n    });\n  }\n\n} // Initialization\n\n\nregisterPostProcessor('Inline-Fonts', new FontOptimizerMiddleware(), // Using process.env because passing Experimental flag through loader is not possible.\n// @ts-ignore\noptions => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS);\nvar _default = processHTML;\nexports.default = _default;","map":{"version":3,"sources":["../../../next-server/lib/post-process.ts"],"names":["MIDDLEWARE_TIME_BUDGET","middlewareRegistry","condition","postProcessData","preloads","images","root","document","timer","Date","middleware","inspectTime","console","name","i","callMiddleWare","FontOptimizerMiddleware","inspect","options","originalDom","tag","OPTIMIZED_FONT_PROVIDERS","url","element","result","fontContent","registerPostProcessor","process","processHTML"],"mappings":";;;;;AAAA,IAAA,eAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,MAAMA,sBAAsB,GAA5B,EAAA;AAmCA,MAAMC,kBAA8C,GAApD,EAAA;;AAEA,SAAA,qBAAA,CAAA,IAAA,EAAA,UAAA,EAAA,SAAA,EAIE;AACAA,EAAAA,kBAAkB,CAAlBA,IAAAA,CAAwB;AAAA,IAAA,IAAA;AAAA,IAAA,UAAA;AAAoBC,IAAAA,SAAS,EAAEA,SAAS,IAAhED;AAAwB,GAAxBA;AAGF;;AAAA,eAAA,WAAA,CAAA,IAAA,EAAA,IAAA,EAAA,OAAA,EAImB;AACjB;AACA,MAAI,CAACA,kBAAkB,CAAvB,CAAuB,CAAvB,EAA4B;AAC1B,WAAA,IAAA;AAEF;;AAAA,QAAME,eAAgC,GAAG;AACvCC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,MAAM,EAFV;AACY;AAD6B,GAAzC;AAKA,QAAMC,IAAiB,GAAG,CAAA,GAAA,eAAA,CAAA,KAAA,EAA1B,IAA0B,CAA1B;AACA,MAAIC,QAAQ,GAAZ,IAAA,CAXiB,CAYjB;;AACA,iBAAA,cAAA,CAAA,UAAA,EAAA,IAAA,EAGE;AACA,QAAIC,KAAK,GAAGC,IAAI,CAAhB,GAAYA,EAAZ;AACAC,IAAAA,UAAU,CAAVA,OAAAA,CAAAA,IAAAA,EAAAA,eAAAA,EAAAA,IAAAA;AACA,UAAMC,WAAW,GAAGF,IAAI,CAAJA,GAAAA,KAApB,KAAA;AACAF,IAAAA,QAAQ,GAAG,MAAMG,UAAU,CAAVA,MAAAA,CAAAA,QAAAA,EAAAA,eAAAA,EAAjBH,IAAiBG,CAAjBH;AACAC,IAAAA,KAAK,GAAGC,IAAI,CAAJA,GAAAA,KAARD,KAAAA;;AACA,QAAIA,KAAK,GAAT,sBAAA,EAAoC;AAClCI,MAAAA,OAAO,CAAPA,IAAAA,CACG,+BAA8BC,IAAK,UAASL,KAAM,MAAKG,WAAY,KAClEH,KAAK,GAAGG,WACT,0CAAyCX,sBAH5CY,SAAAA;AAMF;;AAAA;AAGF;;AAAA,OAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGb,kBAAkB,CAAtC,MAAA,EAA+Ca,CAA/C,EAAA,EAAoD;AAClD,QAAIJ,UAAU,GAAGT,kBAAkB,CAAnC,CAAmC,CAAnC;;AACA,QAAI,CAACS,UAAU,CAAX,SAAA,IAAyBA,UAAU,CAAVA,SAAAA,CAA7B,OAA6BA,CAA7B,EAA4D;AAC1D,YAAMK,cAAc,CAClBd,kBAAkB,CAAlBA,CAAkB,CAAlBA,CADkB,UAAA,EAElBA,kBAAkB,CAAlBA,CAAkB,CAAlBA,CAFF,IAAoB,CAApB;AAKH;AAED;;AAAA,SAAA,QAAA;AAGF;;AAAA,MAAMe,uBAAN,CAA+D;AAAA,EAAA,WAAA,GAAA;AAAA,SAAA,eAAA,GAAA,EAAA;;AAAA,SAAA,MAAA,GA0BpD,OAAA,MAAA,EAAA,KAAA,EAAA,OAAA,KAIJ;AACH,UAAIQ,MAAM,GAAV,MAAA;;AACA,UAAI,CAACN,OAAO,CAAZ,iBAAA,EAAgC;AAC9B,eAAA,MAAA;AAEF;;AAAA,WAAK,MAAL,GAAA,IAAkB,KAAlB,eAAA,EAAwC;AACtC,cAAMI,GAAG,GAAG,KAAA,eAAA,CAAZ,GAAY,CAAZ;;AACA,YAAIE,MAAM,CAANA,OAAAA,CAAgB,qBAAoBF,GAApCE,IAAAA,IAA+C,CAAnD,CAAA,EAAuD;AACrD;AACA;AAEF;;AAAA,cAAMC,WAAW,GAAGP,OAAO,CAAPA,iBAAAA,CAApB,GAAoBA,CAApB;AACAM,QAAAA,MAAM,GAAGA,MAAM,CAANA,OAAAA,CAAAA,SAAAA,EAEN,qBAAoBF,GAAI,KAAIG,WAAW,CAAXA,OAAAA,CAAAA,UAAAA,EAAAA,EAAAA,CAF/BD,iBAASA,CAATA;AAQF;;AAAA,aAAA,MAAA;AAlD2D,KAAA;AAE7DP;;AAAAA,EAAAA,OAAO,CAAA,WAAA,EAAA,KAAA,EAAA,OAAA,EAIL;AACA,QAAI,CAACC,OAAO,CAAZ,iBAAA,EAAgC;AAC9B;AAEF,KAJA,CAIA;;;AACAC,IAAAA,WAAW,CAAXA,gBAAAA,CAAAA,MAAAA,EAAAA,MAAAA,CAGKC,GAAD,IACEA,GAAG,CAAHA,YAAAA,CAAAA,KAAAA,MAAAA,YAAAA,IACAA,GAAG,CAAHA,YAAAA,CADAA,WACAA,CADAA,IAEAC,UAAAA,CAAAA,wBAAAA,CAAAA,IAAAA,CAA+BC,GAAD,IAC5BF,GAAG,CAAHA,YAAAA,CAAAA,WAAAA,EAAAA,UAAAA,CAPRD,GAOQC,CADFC,CANNF,EAAAA,OAAAA,CAUYI,OAAD,IAA0B;AACjC,YAAMD,GAAG,GAAGC,OAAO,CAAPA,YAAAA,CAAZ,WAAYA,CAAZ;AACA,WAAA,eAAA,CAAA,IAAA,CAAA,GAAA;AAZJJ,KAAAA;AAX2D;;AAAA,C,CAsD/D;;;AACAO,qBAAqB,CAAA,cAAA,EAEnB,IAFmB,uBAEnB,EAFmB,EAGnB;AACA;AACCR,OAAD,IAAaA,OAAO,CAAPA,aAAAA,IAAyBS,OAAO,CAAPA,GAAAA,CALxCD,qBAAqB,CAArBA;eAQeE,W","sourcesContent":["import { parse, HTMLElement } from 'node-html-parser'\nimport { OPTIMIZED_FONT_PROVIDERS } from './constants'\n\nconst MIDDLEWARE_TIME_BUDGET = 10\n\ntype postProcessOptions = {\n  optimizeFonts: boolean\n}\n\ntype renderOptions = {\n  getFontDefinition?: (url: string) => string\n}\n\ntype postProcessData = {\n  preloads: {\n    images: Array<string>\n  }\n}\n\ninterface PostProcessMiddleware {\n  inspect: (\n    originalDom: HTMLElement,\n    data: postProcessData,\n    options: renderOptions\n  ) => void\n  mutate: (\n    markup: string,\n    data: postProcessData,\n    options: renderOptions\n  ) => Promise<string>\n}\n\ntype middlewareSignature = {\n  name: string\n  middleware: PostProcessMiddleware\n  condition: ((options: postProcessOptions) => boolean) | null\n}\n\nconst middlewareRegistry: Array<middlewareSignature> = []\n\nfunction registerPostProcessor(\n  name: string,\n  middleware: PostProcessMiddleware,\n  condition?: (options: postProcessOptions) => boolean\n) {\n  middlewareRegistry.push({ name, middleware, condition: condition || null })\n}\n\nasync function processHTML(\n  html: string,\n  data: renderOptions,\n  options: postProcessOptions\n): Promise<string> {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html\n  }\n  const postProcessData: postProcessData = {\n    preloads: {\n      images: [],\n    },\n  }\n  const root: HTMLElement = parse(html)\n  let document = html\n  // Calls the middleware, with some instrumentation and logging\n  async function callMiddleWare(\n    middleware: PostProcessMiddleware,\n    name: string\n  ) {\n    let timer = Date.now()\n    middleware.inspect(root, postProcessData, data)\n    const inspectTime = Date.now() - timer\n    document = await middleware.mutate(document, postProcessData, data)\n    timer = Date.now() - timer\n    if (timer > MIDDLEWARE_TIME_BUDGET) {\n      console.warn(\n        `The postprocess middleware \"${name}\" took ${timer}ms(${inspectTime}, ${\n          timer - inspectTime\n        }) to complete. This is longer than the ${MIDDLEWARE_TIME_BUDGET} limit.`\n      )\n    }\n    return\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i]\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(\n        middlewareRegistry[i].middleware,\n        middlewareRegistry[i].name\n      )\n    }\n  }\n\n  return document\n}\n\nclass FontOptimizerMiddleware implements PostProcessMiddleware {\n  fontDefinitions: Array<string> = []\n  inspect(\n    originalDom: HTMLElement,\n    _data: postProcessData,\n    options: renderOptions\n  ) {\n    if (!options.getFontDefinition) {\n      return\n    }\n    // collecting all the requested font definitions\n    originalDom\n      .querySelectorAll('link')\n      .filter(\n        (tag: HTMLElement) =>\n          tag.getAttribute('rel') === 'stylesheet' &&\n          tag.hasAttribute('data-href') &&\n          OPTIMIZED_FONT_PROVIDERS.some((url) =>\n            tag.getAttribute('data-href').startsWith(url)\n          )\n      )\n      .forEach((element: HTMLElement) => {\n        const url = element.getAttribute('data-href')\n        this.fontDefinitions.push(url)\n      })\n  }\n  mutate = async (\n    markup: string,\n    _data: postProcessData,\n    options: renderOptions\n  ) => {\n    let result = markup\n    if (!options.getFontDefinition) {\n      return markup\n    }\n    for (const key in this.fontDefinitions) {\n      const url = this.fontDefinitions[key]\n      if (result.indexOf(`<style data-href=\"${url}\">`) > -1) {\n        // The font is already optimized and probably the response is cached\n        continue\n      }\n      const fontContent = options.getFontDefinition(url)\n      result = result.replace(\n        '</head>',\n        `<style data-href=\"${url}\">${fontContent.replace(\n          /(\\n|\\s)/g,\n          ''\n        )}</style></head>`\n      )\n    }\n    return result\n  }\n}\n\n// Initialization\nregisterPostProcessor(\n  'Inline-Fonts',\n  new FontOptimizerMiddleware(),\n  // Using process.env because passing Experimental flag through loader is not possible.\n  // @ts-ignore\n  (options) => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS\n)\n\nexport default processHTML\n"]},"metadata":{},"sourceType":"script"}